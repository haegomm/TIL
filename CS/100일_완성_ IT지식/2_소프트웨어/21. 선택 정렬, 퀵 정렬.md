### 21. 선택 정렬, 퀵 정렬

---

---



#### 🎈 정렬

- 2개 이상의 자료를 특정 기준에 의해 오름차순 혹은 내림차순으로 재배열하는 것
- 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 함



#### 🎈 선택 정렬

- 최소 선택 정렬(Min-selecton sort)
  - 매번 가장 작은 데이터를 선택하고 데이터 간의 배치를 변경하며 오름차순으로 정렬
- 최대 선택 정렬(Max-selection sort)
  - 매번 가장 큰 데이터를 선택하고 데이터 간의 배치를 변경하며 내림차순으로 정렬



1️⃣ 전체 데이터에서 가장 작은(큰) 데이터를 선택하고 맨 앞에 있는 데이터와 자리를 바꿈

2️⃣ 그 다음으로 작은(큰) 데이터를 선택하고 맨 앞에서 두 번째 데이터와 자리를 바꿈

3️⃣ 위와 같은 방식으로 오름차순(내림차순)으로 정렬이 완료될 때까지 데이터를 선택하고 자리를 바꾸는 과정을 반복



- 선택 정렬의 시간 복잡도
  - N개의 데이터가 있을 때 N-1번만큼 가장 작은 데이터를 찾고 맨 앞으로 보내는 과정이 필요
  - O(N^2)
  - 만약 정렬의 항목의 수가 2배가 되면 4배의 시간이 걸리고 10배라면 100배의 시간이 걸림



- 장점
  - 자료 이동 횟수가 미리 결정
  - 알고리즘이 단순
  - 다른 메모리 공간을 필요로 하지 않음]
  - 교환이 일어나야 하는 자료상태에서 비교적 효율적
- 단점
  - 비효율적
  - 불안정 정렬
    - 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있음

----



#### 🎈 퀵 정렬

- 분할 정복 방법을 통해 주어진 배열을 정렬
  - 분할 정복 방법: 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 문제를 해결하는 전략
- 불안 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.



1️⃣ 정복(Conquer)

​	부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용

2️⃣ 분할(Divide)

​	입력 배열을 피벗 기준으로 비균등하게 2개의 부분 배열

(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 

피벗을 중심으로 오른쪽: 피벗보다 큰 요소들) 로 분할

3️⃣ 분할된 두 개의 배열에 대해 재귀적으로 이 과정을 반복



- 시간 복잡도
  - O(Nlog₂N)



- 장점
  - 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환
  - 시간 복잡도가 O(Nlog₂N) 를 가지는 다른 정렬 알고리즘과 비교했을 때 가장 빠름
  - 정렬하고자 하는 배열 안에서 교환하는 방식 -> 다른 메모리 공간 필요❌
- 단점
  - 불안정 정렬
  - 정렬된 배열에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 걸림
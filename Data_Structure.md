# 데이터 구조

---

---



## 데이터 구조 활용

- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
  - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
  - 객체의 기능
    - **데이터 구조.메서드()**
        list.append(10)



----



## 파이썬 공식 문서의 표기법

- python 구문이 아니며, 문법을 표기하기 위한 것임
- ```python
  str.replace(old, new[,count])
  ```
  - old, new는 필수/ [,count]는 선택적 인자 의미



----

---

# 순서가 있는 문자열

---

## 문자열

- 문자들의 나열(sequence of characters)
  
  - 모든 문자는 str 타입(immutable)
  - ```python
    word = 'hello'
    print(id(word)) # 메모리 주소(사물함 번호 같은 것이라고 생각하면 됨!)
    ```

- 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
  
  - 문자열을 묶을 때 동일한 문장부호를 활용
  
  - PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함
    
    - 문자열을 표현할 때 작은 따옴표를 사용하고 싶다면 이후 모든 문자열을 작은 따옴표로 쭉 작성하는 것!

---- 



### 문자열 조회/탐색 및 변경 메서드

##### 문자열 조회/탐색

- s.find(x)
  
  - x의 첫 번재 위치를 반환, 없으면 -1을 반환
    
    - (*오류가 안남* -> 프로그램 진행이 된다는 뜻)



- s.index(x)
  
  - x의 첫 번째 위치를 반환, 없으면 오류 발생(프로그램이 멈춘다는 뜻)



- s.isalpha()
  
  - 알파벳 문자 여부
    
    - 단순 알파벳이 아닌 유티코드 상 letter(한국어도 포함)



- s.isupper()
  
  - 대문자 여부



- s.islower()
  
  - 소문자 여부



- s.istitle()
  
  - 타이틀 형식 여부



#### 문자열 변경 메서드

- s.replace(old, new[,count])
  
  - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  
  - count를 지정하면, 해당 개수만큼만 시행



- s.strip([chars])
  
  - 특정 문자를 지정하면,
    
    - 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip)
  
  - 문자열을 지정하지 않으면 공백을 제거함



- s.split(sep=None, maxsplit =-1)
  
  - 문자열을 특정한 단위로 나눠 리스트로 반환
    
    - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음(*이해가 잘 안됨 다시 확인*)
    
    - maxsplit이 -1인 경우에는 제한이 없음



- 'separator'.json([iterable])
  
  - 반복가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환
    
    - iterable에 문자열이 아닌 값이 있으면 TypeError 발생

---

## 리스트

### 리스트의 생성과 접근

- 리스트는 [] 혹은 list()를 통해 생성
  
  - 파이썬에는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음
  
  - 생성된 이후 내용 변경 가능 -> 가변 자료형

- 순서가 있는 시퀀스로 인덱스를 통해 접근이 가능
  
  - 값에 대한 접근은 list[i]

---

### 리스트 메서드

##### 값 추가 및 삭제

- l.append( x )
  
  - 리스트에 값을 추가함
    
    - 추가 == 덧붙인다



- l.insert( i, x )
  
  - 정해진 위치 i에 x값을 추가함



- l.extend(iterable)
  
  - 리스트에 iterable의 항목을 추가함



- l.remove( x )
  
  - 리스트에서 값이 x인 것 삭제



- l.pop( i )
  
  - 정해진 위치 i에 있는 값을 삭제하고, 그 항목을 반환함
  
  - i가 지정되지 않으면, 마짐가 항목을 삭제하고 반환함



- l.clear()
  
  - 모든 항목을 삭제함



##### 탐색 및 정렬

- l.index( x )
  
  - x값을 찾아 해당 index 값을 반환



- l.count( x )
  
  - 원하는 값의 개수를 반환함



- l.sort()
  
  - 원본 리스트를 정렬함. None 반환
  
  - sorted 함수와 비교할 것
    
    - sort() : 원본을 바꿈
    
    - sorted() : 원본은 그대로 두고 원본을 본 딴? 녀석을 정렬



- l.reverse()
  
  - 순서를 반대로 뒤집음(정렬하는 것이 아님)
    
    - 원본을 뒤집는 것



---

## 튜플

### 튜플의 정의

- 튜플은 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
  
  - 리스트와의 차이점은 생성 후, 담고 있는 값 변경이 불가 (불변 자료형)

- 항상 소괄호 형태로 사용

---

### 튜플 관련 메서드

- 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메서드만을 지원

- 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일



---

---

# 비시퀀스형 데이터 구조

## 셋(set)

- Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  
  - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
  
  - 순서가 없기 때문에 인덱스를 이용한 접근 불가능

- 수학에서의 집합을 표현한 컨테이너
  
  - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재 x )
  
  - 중복된 값이 존재하지 않음

- 담고 있는 요소를 삽입 변경, 삭제 가능 -> 가변 자료형(mutable)

---

### 셋 메서드

##### 추가 및 변경

- s.add(elem)
  
  - 셋에 값을 추가



- s.update(*others)
  
  - 여러 값을 추가



- s.remove(elem)
  
  -  set에서 삭제하고 없으면,  KeyError



- s.discard(elem)
  
  - 셋에서 삭제하고 없어도 에러가 발생하지 않음



- s.pop()
  
  - 임의의 원소를 제거해 반환



---

## 딕셔너리(Dictionary)

### 딕셔너리 정의

- 키 - 값( key - value ) 쌍으로 이뤄진 자료형(3.7부터는 ordered, 이하 버전은 unordered)

- Dictionary 의 키(key)
  
  - key는 변경 불가능한 데이터(immutable)만 활용 가능
    
    - string, integer, float, boolean, tuple, range

- 각 키의 값(values)
  
  - 어떠한 형태든 관계없음



### 딕셔너리 메서드

##### 조회

- d.get(key[,default])
  
  - key를 통해 value를 가져옴
  
  - KeyError가 발생하지 않으며, deault 값을 설정할 수 있음(기본:None)



##### 추가 및 삭제

- d.pop(key[,default])
  
  - key가 딕셔너리에 있으면 제거하고 해당 값을 반환
  
  - 그렇지 않으면 default를 반환
  
  - default 값이 없으면 KeyError



- d.update()
  
  - 값을 제공하는 key, value로 덮어씀



---

---

# 얕은 복사와 깊은 복사

## 복사 방법

- 할당(Assignment)

- 얕은 복사(Shallow copy)

- 깊은 복사(Deep copy)

---



### 할당(Assignment)

- 대입 연산자(=)
  
  - 리스트 복사 확인하기
  
  *대입 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사(주소를 복사)*

       *해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향(사물함 주소로 가서 [0]번째 값을 바꾸는거라 원본이랑 복사본 둘 다 바뀌게 됨)*



---

### 얕은 복사(Shallow copy)

- Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)

- 주의사항
  
  - 복사하는 리스트의 원소가 주소를 참조하는 경우



---



### 깊은 복사(Deep copy)

- 리스트 복사 확인하기(주소자체도 복사..하는 느낌..)

- 리스트 복사 할 때 딥카피를 써야하겠다..라는 생각만 가지고 가도 됨..!




